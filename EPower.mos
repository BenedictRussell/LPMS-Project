model EPowerModel
  uses "mmxprs"


  declarations
    Emiss: set of string
    Source:	set of string
    Times:	set of integer
    PeriodLength:	array(Times) of real
    Demand:		array(Times) of real
    MaxOutput:  array(Source) of real
    RunningCost:    array(Source) of real
    IncreaseCost:   array(Source) of real
    Emissions:    array(Emiss, Source) of real
    EmissionsLimit: array(Emiss) of real
    ElectricityPrice:	real
    MaxHydroReserve:	real
    NaturalHydroInflow:		real
    HydroPowerEfficiencyFrac:	real
    PowerOutput: array(Source, Times) of mpvar
    IncreasedOutput: array(Source, Times) of mpvar
    PumpDemand: array(Times) of mpvar
    HydroReservePower: array(Times) of mpvar
  end-declarations

  initialisations from "EPower.dat"
    Emiss Source Times PeriodLength Demand MaxOutput RunningCost
    IncreaseCost Emissions EmissionsLimit ElectricityPrice MaxHydroReserve NaturalHydroInflow
    HydroPowerEfficiencyFrac
  end-initialisations

  ! Constraint on maximum power output per source
  forall(s in Source, t in Times)
    OutputCS(s,t) := PowerOutput(s,t) <= MaxOutput(s)

  ! The running cost per time period
  forall(t in Times)
    RunCost(t) :=  PeriodLength(t)*sum(s in Source) RunningCost(s)*PowerOutput(s,t)

  ! Total running cost
  TotalRunningCost := sum(t in Times) RunCost(t)

  ! The increase cost
  forall(s in Source, t in Times) do
    if t=1 then
      WrapAroundIncreaseCS := IncreasedOutput(s,t) >= PowerOutput(s,t) - PowerOutput(s,6)
    else
      IncreaseCS:= IncreasedOutput(s,t) >= PowerOutput(s,t) - PowerOutput(s,t-1)
    end-if
    NonnegativeIncreaseCS := IncreasedOutput(s,t) >= 0
  end-do

  ! The total cost of increasing output
  TotalIncreaseCost := sum(t in Times, s in Source) IncreasedOutput(s,t)*IncreaseCost(s)

  ! Emission Constraints
  forall(e in Emiss)
    EmissionCS(e) := sum(s in Source, t in Times) Emissions(e,s)*PowerOutput(s,t) <= EmissionsLimit(e)


  ! Demand Constraints

  ! Power Output per period
  forall(t in Times)
    PeriodPowerOutput(t) := sum(s in Source) PowerOutput(s,t)


  ! Demand per period
  forall(t in Times)
    DemandCS(t) := PeriodPowerOutput(t) - PumpDemand(t) + HydroReservePower(t) = Demand(t)


  ! Hydro Storage capacity

  forall(t in Times) do
    if t=1 then
      HydroReservePower(t) = HydroReservePower(6) + PeriodLength(t)*(PumpDemand(t)*HydroPowerEfficiencyFrac + NaturalHydroInflow - PowerOutput(6,t))
    else
      HydroReservePower(t)  = HydroReservePower(t-1) + PeriodLength(t)*(PumpDemand(t)*HydroPowerEfficiencyFrac + NaturalHydroInflow - PowerOutput(6,t))
    end-if
    HydrocapacityCS(t) := HydroReservePower(t) <= MaxHydroReserve
  end-do



  ! Define Revenue
  Revenue := sum(t in Times) PeriodPowerOutput(t)*ElectricityPrice



  ! Objective Function: Profit
  Profit := Revenue - TotalRunningCost - TotalIncreaseCost



  maximise(Profit)

  write("The Total Profit is ", getsol(Profit))

  writeln

  write("Sources")
  forall(s in Source) write(",", s)
  writeln

  forall(t in Times) do
    write("Period ", t)
    forall(s in Source) write(",", getsol(PowerOutput(s,t)))
    writeln
  end-do
  writeln

  forall(e in Emiss)
    writeln("The slack on the ", Emiss(e),  " constraint is ", getslack(EmissionCS(e)))
  writeln

  forall(s in Source) write(",",s)
  writeln
  forall(t in Times) do
    writeln
    forall(s in Source) write(",",getslack(OutputCS(s,t)))
  end-do
  writeln

  forall(t in Times)
    writeln("For time period ", t, " the slack on the demand constraint is ", getslack(DemandCS(t)))
  writeln

  writeln("The total revenue is ", getsol(Revenue))
  writeln("The total running cost is ", getsol(TotalRunningCost))
  writeln("The total increasing cost is ", getsol(TotalIncreaseCost))

  writeln("The total power ouput for each period is")
  forall(t in Times)
    writeln(t,",", getsol(PeriodPowerOutput(t)))

end-model
