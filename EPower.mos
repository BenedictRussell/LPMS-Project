model EPowerModel
  uses "mmxprs"


  declarations
    Emiss: set of string
    Source:	set of string
    Times:	set of integer
    PeriodLength:	array(Times) of real
    Demand:		array(Times) of real
    MaxOutput:  array(Source) of real
    RunningCost:    array(Source) of real
    IncreaseCost:   array(Source) of real
    Emissions:    array(Emiss, Source) of real
    EmissionsLimit: array(Emiss) of real
    ElectricityPrice:	real
    MaxHydroReserve:	real
    NaturalHydroInflow:		real
    HydroPowerEfficiencyFrac:	real
    PowerOutput: array(Source, Times) of mpvar
    IncreasedOutput: array(Source, Times) of mpvar
    PumpDemand: array(Times) of mpvar
    HydroReservePower: array(Times) of mpvar
    EmissionFactor: array(Emiss) of real
  end-declarations

  initialisations from "EPower.dat"
    Emiss Source Times PeriodLength Demand MaxOutput RunningCost
    IncreaseCost Emissions EmissionsLimit ElectricityPrice MaxHydroReserve NaturalHydroInflow
    HydroPowerEfficiencyFrac EmissionFactor
  end-initialisations

  ! Constraint on maximum power output per source
  forall(s in Source, t in Times)
    OutputCS(s,t) := PowerOutput(s,t) <= MaxOutput(s)

  ! The running cost per time period
  forall(t in Times)
    RunCost(t) :=  PeriodLength(t)*sum(s in Source) RunningCost(s)*PowerOutput(s,t)

  ! Total running cost
  TotalRunningCost := sum(t in Times) RunCost(t)

  ! The increase cost
  forall(s in Source, t in Times) do
    if t=1 then
      WrapAroundIncreaseCS(s,t) := IncreasedOutput(s,t) >= PowerOutput(s,t) - PowerOutput(s,6)
    else
      IncreaseCS(s,t):= IncreasedOutput(s,t) >= PowerOutput(s,t) - PowerOutput(s,t-1)
    end-if
    NonnegativeIncreaseCS(s,t) := IncreasedOutput(s,t) >= 0
  end-do

  ! The total cost of increasing output
  TotalIncreaseCost := sum(t in Times, s in Source) IncreasedOutput(s,t)*IncreaseCost(s)

  ! Emission Constraints
  forall(e in Emiss)
    EmissionCS(e) := sum(s in Source, t in Times) Emissions(e,s)*PowerOutput(s,t)*PeriodLength(t) <= EmissionsLimit(e)*EmissionFactor(e)


  ! Demand Constraints

  ! Power Output per period
  forall(t in Times)
    PeriodPowerOutputRate(t) := sum(s in Source) PowerOutput(s,t)


  ! Demand per period
  forall(t in Times)
    DemandCS(t) := PeriodPowerOutputRate(t) - PumpDemand(t) = Demand(t)


  ! Hydro Storage capacity

  forall(t in Times) do
    if t=1 then
      HydroCS(t) := HydroReservePower(t) = HydroReservePower(6) + PeriodLength(t)*(PumpDemand(t)*HydroPowerEfficiencyFrac + NaturalHydroInflow - PowerOutput("Hydro",t))
    else
      HydroCS(t) := HydroReservePower(t) = HydroReservePower(t-1) + PeriodLength(t)*(PumpDemand(t)*HydroPowerEfficiencyFrac + NaturalHydroInflow - PowerOutput("Hydro",t))
    end-if
    
    HydroReservePower(t) <= MaxHydroReserve
    HydroReservePower(t) >= 0
  end-do



  ! Define Revenue
  Revenue := sum(t in Times) (PeriodPowerOutputRate(t) - PumpDemand(t))*PeriodLength(t)*ElectricityPrice



  ! Objective Function: Profit
  Profit := Revenue - TotalRunningCost - TotalIncreaseCost



  maximise(Profit)


  !fopen("EPower.csv", F_OUTPUT)
  write("The Total Profit is ", getsol(Profit))

  writeln

  write("Sources")
  forall(s in Source) write(",", s)
  writeln

  forall(t in Times) do
    write("Period ", t)
    forall(s in Source) write(",", getsol(PowerOutput(s,t)))
    writeln
  end-do
  writeln

  forall(e in Emiss)
    writeln("The slack on the ", Emiss(e),  " constraint is ", getslack(EmissionCS(e)))
  writeln



  forall(t in Times)
    writeln("For time period ", t, " the slack on the demand constraint is ", getslack(DemandCS(t)))
  writeln

  writeln("The total revenue is ", getsol(Revenue))
  writeln("The total running cost is ", getsol(TotalRunningCost))
  writeln("The total increasing cost is ", getsol(TotalIncreaseCost))

  writeln("The total power ouput for each period is")
  forall(t in Times)
    writeln(t,",", getsol(PeriodPowerOutputRate(t)))

  
  writeln
  writeln("The increase of optput matris is")
  forall(t in Times) do
    write("Period ", t)
    forall(s in Source) write(",", getsol(IncreasedOutput(s,t)))
    writeln
  end-do
  writeln



  writeln("The amount of water in the reserve in each period is ")
  forall(t in Times)
    writeln(t,",", getsol(HydroReservePower(t)))

  writeln("The rate of water pumped in each period is ")
  forall(t in Times)
    writeln(t,",", getsol(PumpDemand(t)))

  !fclose(F_OUTPUT)

end-model



forall(t in Times) do
    if t=1 then
      HydroReservePower(t) := HydroReservePower(6) + PeriodLength(t)*(PumpDemand(t)*HydroPowerEfficiencyFrac + NaturalHydroInflow - PowerOutput("Hydro",t))
    else
      HydroReservePower(t)  := HydroReservePower(t-1) + PeriodLength(t)*(PumpDemand(t)*HydroPowerEfficiencyFrac + NaturalHydroInflow - PowerOutput("Hydro",t))
    end-if
    HydroReservePower(t) <= MaxHydroReserve
    HydroReservePower(t) >= 0
  end-do